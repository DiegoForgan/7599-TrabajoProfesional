using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Random = UnityEngine.Random;

public class RoomFirstDungeonGenerator : SimpleRandomWalkDungeonGenerator
{
    // Minimum size of the rooms that are going to be generated by splitting the total dungeon space
    [SerializeField] private int minRoomWidth = 4;
    [SerializeField] private int minRoomHeigth = 4;
    // Total size of the dungeon to be filled with rooms and corridors
    [SerializeField] private int dungeonWidth = 20;
    [SerializeField] private int dungeonHeigth = 20;
    // Offset required to not build rooms too close to each other making just one big segment
    [SerializeField] [Range(0,10)] private int offset = 1;
    // This is used to select beetween random walk generated rooms or regular square ones
    [SerializeField] private bool randomWalkRooms = false;

    protected override void RunProceduralGeneration()
    {
        CreateRooms();    
    }

    private void CreateRooms()
    {
        List<BoundsInt> roomsList = BinarySpacePartitioning(new BoundsInt((Vector3Int) startPosition,
         new Vector3Int(dungeonWidth,dungeonHeigth,0)), minRoomWidth, minRoomHeigth);

        HashSet<Vector2Int> floor = new HashSet<Vector2Int>();
        floor = CreateSimpleRooms(roomsList);

        tilemapVisualizer.PaintFloortiles(floor);
        HashSet<Vector2Int> wallsPositions = WallGenerator.GenerateWalls(floor);
        tilemapVisualizer.PaintWallstiles(wallsPositions);
    }

    private List<BoundsInt> BinarySpacePartitioning(BoundsInt spaceToSplit, int minWidth, int minHeigth)
    {
        Queue<BoundsInt> roomsQueue = new Queue<BoundsInt>();
        List<BoundsInt> roomsList = new List<BoundsInt>();
        roomsQueue.Enqueue(spaceToSplit);

        while (roomsQueue.Count > 0)
        {
            BoundsInt room = roomsQueue.Dequeue();
            // Checks if the current splitted space has enough space to contain a room
            if ( room.size.x >= minWidth && room.size.y >= minHeigth){
                // This is just a simple way to choose randomly beetween a Vertical split or a Horizontal split
                if (Random.value < 0.5f){
                    //Prefer splitting Horizontally
                    if(room.size.y >= (minHeigth * 2)) SplitHorizontally(minHeigth,roomsQueue,room);
                    else if (room.size.x >= (minRoomWidth * 2)) SplitVertically(minWidth,roomsQueue,room);
                    else roomsList.Add(room);

                }
                else{
                    //Prefer splitting Vertically
                    if (room.size.x >= (minRoomWidth * 2)) SplitVertically(minWidth,roomsQueue,room);
                    else if(room.size.y >= (minHeigth * 2)) SplitHorizontally(minHeigth,roomsQueue,room);
                    else roomsList.Add(room);
                }    
            }     
        }

        return roomsList;
    }

    private void SplitVertically(int minWidth, Queue<BoundsInt> roomsQueue, BoundsInt room)
    {
        int xSplit = Random.Range(1,room.size.x);
        BoundsInt room1 = new BoundsInt(room.min,new Vector3Int(xSplit,room.size.y,room.size.z));
        BoundsInt room2 = new BoundsInt(new Vector3Int(room.min.x + xSplit,room.min.y,room.min.z),
            new Vector3Int(room.size.x - xSplit,room.size.y,room.size.z));
        roomsQueue.Enqueue(room1);
        roomsQueue.Enqueue(room2);
    }

    private void SplitHorizontally(int minHeigth, Queue<BoundsInt> roomsQueue, BoundsInt room)
    {
        int ySplit = Random.Range(1,room.size.y);
        BoundsInt room1 = new BoundsInt(room.min, new Vector3Int(room.size.x, ySplit, room.size.z));
        BoundsInt room2 = new BoundsInt(new Vector3Int(room.min.x,room.min.y + ySplit, room.min.z),
            new Vector3Int(room.size.x, room.size.y - ySplit, room.size.z));
        roomsQueue.Enqueue(room1);
        roomsQueue.Enqueue(room2);
    }

    private HashSet<Vector2Int> CreateSimpleRooms(List<BoundsInt> roomsList)
    {
        HashSet<Vector2Int> floor = new HashSet<Vector2Int>();
        foreach (BoundsInt room in roomsList)
        {
            for (int col = offset; col < (room.size.x - offset); col++)
            {
                for (int row = offset; row < (room.size.y - offset); row++)
                {
                    Vector2Int position = (Vector2Int) room.min + new Vector2Int(col,row);
                    floor.Add(position);     
                }    
            }
        }
        return floor;
    }
}
